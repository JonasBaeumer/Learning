"""
There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.

A province is a group of directly or indirectly connected cities and no other cities outside of the group.

You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.

Return the total number of provinces.
"""
"""
1 1 0
0 0 1
1 1 1
"""

"""
Approach: 
	1. Somehow build up the provinces/sets to show me how many there are
		Questions:
			- Can I make my life easier by reforming the input?
				No: Already have a valid graph structure 
			- Is our graph bidirectional or directional?
				Bidirectional -> I only have half of the edges in our graph since we have the each edge twice (Potential improvement for the graph)
			- Can I do this in place? POTENTIAL OPTIMIZATION
			- 
	We beed to build up sets that show us all the provinces in the graph (which nodes belong to the same set, and which ones belong to other sets)
	-> Union-Find()
		1. Build up the sets (Run: O(e*v), Space: O(n)) 
		2. Go through the sets and find all nodes where the root is itself (Run: O(n))
			Find capitals of all provinces
	
	Bug with this approach: 
		When we connect the nodes, we always overwrite connections. We dont check wether islands are already connected.
		Because if there are we dont need to add the connection because they already belong to the same island. 
		Furthermore, when we do the Union approach we also need to decide on how we find which nodes are already connected
		Because when we add larger provinces together not all nodes of the old province will point to the same root, some will
		point to the old root which in turn points to the new root. Therefore during updating we have to decide on what do to 
		with this node. Do change the pointer of all nodes of the old graph to the new root (then all would point to the root)
		or do we just change the root nodes counter but then during merging need to always traverse the graph to check if node 
		is actually already in the graph.
"""
test = [[1, 1, 0], 
	[1, 1, 1], 
	[0, 1, 1]]

def findCircleNum(isConnected: list[list[int]]) -> int:
	num_of_nodes = len(isConnected)
	
	parent = list(range(num_of_nodes))
	
	def find(x: int) -> int:
		if parent[x] == x:
			return x
		return find(parent[x])
	
	number_of_capitals = 0
	for a in range(num_of_nodes):
		for b in range(a, num_of_nodes):
			# Only union if nods are connected
			if isConnected[a][b]:
				capital_of_a = find(a)
				capital_of_b = find(b)
				# If not the same we merge
				if capital_of_a != capital_of_b:
					parent[capital_of_b] = capital_of_a
	for i in range(len(parent)):
		if parent[i] == i:
			number_of_capitals += 1
	return number_of_capitals

print(findCircleNum(test))
	

def findCircleNum_attempt_1(isConnected: list[list[int]]) -> int:
	num_of_nodes = len(isConnected)
	num_of_capitals = 0
	# Initialize our union datastructure
	provinces = [n for n in range(num_of_nodes)]
	print(provinces)
	# Add all of our edges and consecutively merge out sets
	for i in range(num_of_nodes):
		for j in range(i+1, len(isConnected[0])):
			# If there is an edge we have to perform union operation
			if isConnected[i][j] == 1:
				provinces[j] == i
			# If not do nothing
	# Find all capitals in union datastructure
	print(provinces)
	for i in range(len(provinces)):
		if provinces[i] == i:
			num_of_capitals += 1
	return num_of_capitals
		

